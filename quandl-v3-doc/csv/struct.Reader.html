<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Reader` struct in crate `csv`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Reader">

    <title>csv::Reader - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc struct">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Struct Reader</p><div class="block items"><ul><li><a href="#methods">Methods</a></li><li><a href="#implementations">Trait Implementations</a></li></ul></div><p class='location'><a href='index.html'>csv</a></p><script>window.sidebarCurrent = {name: 'Reader', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>csv</a>::<wbr><a class="struct" href=''>Reader</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/csv/reader.rs.html#646-659' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Reader&lt;R&gt; { /* fields omitted */ }</pre><div class='docblock'><p>A already configured CSV reader.</p>

<p>A CSV reader takes as input CSV data and transforms that into standard Rust
 values. The most flexible way to read CSV data is as a sequence of records,
 where a record is a sequence of fields and each field is a string. However,
 a reader can also deserialize CSV data into Rust types like <code>i64</code> or
 <code>(String, f64, f64, f64)</code> or even a custom struct automatically using
 Serde.</p>

<p># Configuration</p>

<p>A CSV reader has a couple convenient constructor methods like <code>from_path</code>
 and <code>from_reader</code>. However, if you want to configure the CSV reader to use
 a different delimiter or quote character (among many other things), then
 you should use a <a href="struct.ReaderBuilder.html"><code>ReaderBuilder</code></a> to construct
 a <code>Reader</code>. For example, to change the field delimiter:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">ReaderBuilder</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city;country;pop
Boston;United States;4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">ReaderBuilder</span>::<span class="ident">new</span>()
         .<span class="ident">delimiter</span>(<span class="string">b&#39;;&#39;</span>)
         .<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">records</span>().<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>

<p># Error handling</p>

<p>In general, CSV <em>parsing</em> does not ever return an error. That is, there is
 no such thing as malformed CSV data. Instead, this reader will prioritize
 finding a parse over rejecting CSV data that it does not understand. This
 choice was inspired by other popular CSV parsers, but also because it is
 pragmatic. CSV data varies wildly, so even if the CSV data is malformed,
 it might still be possible to work with the data. In the land of CSV, there
 is no &quot;right&quot; or &quot;wrong,&quot; only &quot;right&quot; and &quot;less right.&quot;</p>

<p>With that said, a number of errors can occur while reading CSV data:</p>

<ul>
<li>By default, all records in CSV data must have the same number of fields.
If a record is found with a different number of fields than a prior
record, then an error is returned. This behavior can be disabled by
enabling flexible parsing via the <code>flexible</code> method on
<a href="struct.ReaderBuilder.html"><code>ReaderBuilder</code></a>.</li>
<li>When reading CSV data from a resource (like a file), it is possible for
reading from the underlying resource to fail. This will return an error.</li>
<li>When reading CSV data into <code>String</code> or <code>&amp;str</code> fields (e.g., via a
<a href="struct.StringRecord.html"><code>StringRecord</code></a>), UTF-8 is strictly
enforced. If CSV data is invalid UTF-8, then an error is returned. If
you want to read invalid UTF-8, then you should use the byte oriented
APIs such as <a href="struct.ByteRecord.html"><code>ByteRecord</code></a>. If you need explicit
support for another encoding entirely, then you&#39;ll need to use another
crate to transcode your CSV data to UTF-8 before parsing it.</li>
<li><p>When using Serde to deserialize CSV data into Rust types, it is possible
for a number of additional errors to occur. For example, deserializing
a field <code>xyz</code> into an <code>i32</code> field will result in an error.</p>

<p>For more details on the precise semantics of errors, see the
<a href="enum.Error.html"><code>Error</code></a> type.</p></li>
</ul>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class="struct" href="../csv/struct.Reader.html" title="struct csv::Reader">Reader</a>&lt;<a class="struct" href="../csv/struct.Reader.html" title="struct csv::Reader">Reader</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/fs/struct.File.html" title="struct std::fs::File">File</a>&gt;&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/csv/reader.rs.html#700-727' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.from_path' class="method"><span id='from_path.v' class='invisible'><code>fn <a href='#method.from_path' class='fnname'>from_path</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(path: P) -&gt; <a class="type" href="../csv/type.Result.html" title="type csv::Result">Result</a>&lt;<a class="struct" href="../csv/struct.Reader.html" title="struct csv::Reader">Reader</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/fs/struct.File.html" title="struct std::fs::File">File</a>&gt;&gt;</code></span></h4>
<div class='docblock'><p>Create a new CSV parser with a default configuration for the given
file path.</p>

<p>To customize CSV parsing, use a <code>ReaderBuilder</code>.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
<span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_path</span>(<span class="string">&quot;foo.csv&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">for</span> <span class="ident">result</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">records</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">record</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</pre>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a>&gt; <a class="struct" href="../csv/struct.Reader.html" title="struct csv::Reader">Reader</a>&lt;R&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/csv/reader.rs.html#729-1694' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.from_reader' class="method"><span id='from_reader.v' class='invisible'><code>fn <a href='#method.from_reader' class='fnname'>from_reader</a>(rdr: R) -&gt; <a class="struct" href="../csv/struct.Reader.html" title="struct csv::Reader">Reader</a>&lt;R&gt;</code></span></h4>
<div class='docblock'><p>Create a new CSV parser with a default configuration for the given
 reader.</p>

<p>To customize CSV parsing, use a <code>ReaderBuilder</code>.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">for</span> <span class="ident">result</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">records</span>() {
         <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">record</span>);
     }
     <span class="prelude-val">Ok</span>(())
 }</pre>
</div><h4 id='method.deserialize' class="method"><span id='deserialize.v' class='invisible'><code>fn <a href='#method.deserialize' class='fnname'>deserialize</a>&lt;D&gt;(&amp;mut self) -&gt; <a class="struct" href="../csv/struct.DeserializeRecordsIter.html" title="struct csv::DeserializeRecordsIter">DeserializeRecordsIter</a>&lt;R, D&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Returns a borrowed iterator over deserialized records.</p>

<p>Each item yielded by this iterator is a <code>Result&lt;D, Error&gt;</code>.
 Therefore, in order to access the record, callers must handle the
 possibility of error (typically with <code>try!</code> or <code>?</code>).</p>

<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
 default), then this does not include the first record. Additionally,
 if <code>has_headers</code> is enabled, then deserializing into a struct will
 automatically align the values in each row to the fields of a struct
 based on the header row.</p>

<p># Example</p>

<p>This shows how to deserialize CSV data into normal Rust structs. The
 fields of the header row are used to match up the values in each row
 to the fields of the struct.</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;
 <span class="attribute">#[<span class="ident">macro_use</span>]</span>
 <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_derive</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
 <span class="kw">struct</span> <span class="ident">Row</span> {
     <span class="ident">city</span>: <span class="ident">String</span>,
     <span class="ident">country</span>: <span class="ident">String</span>,
     <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;popcount&quot;</span>)]</span>
     <span class="ident">population</span>: <span class="ident">u64</span>,
 }

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">deserialize</span>();

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
             <span class="ident">city</span>: <span class="string">&quot;Boston&quot;</span>.<span class="ident">to_string</span>(),
             <span class="ident">country</span>: <span class="string">&quot;United States&quot;</span>.<span class="ident">to_string</span>(),
             <span class="ident">population</span>: <span class="number">4628910</span>,
         });
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>

<p># Rules</p>

<p>For the most part, any Rust type that maps straight-forwardly to a CSV
 record is supported. This includes maps, structs, tuples and tuple
 structs. Other Rust types, such as <code>Vec</code>s, arrays, and enums have
 a more complicated story. In general, when working with CSV data, one
 should avoid <em>nested sequences</em> as much as possible.</p>

<p>Maps, structs, tuples and tuple structs map to CSV records in a simple
 way. Tuples and tuple structs decode their fields in the order that
 they are defined. Structs will do the same only if <code>has_headers</code> has
 been disabled using <a href="struct.ReaderBuilder.html"><code>ReaderBuilder</code></a>,
 otherwise, structs and maps are deserialized based on the fields
 defined in the header row. (If there is no header row, then
 deserializing into a map will result in an error.)</p>

<p>Nested sequences are supported in a limited capacity. Namely, they
 are flattened. As a result, it&#39;s often useful to use a <code>Vec</code> to capture
 a &quot;tail&quot; of fields in a record:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;
 <span class="attribute">#[<span class="ident">macro_use</span>]</span>
 <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_derive</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">ReaderBuilder</span>;

 <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
 <span class="kw">struct</span> <span class="ident">Row</span> {
     <span class="ident">label</span>: <span class="ident">String</span>,
     <span class="ident">values</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
 }

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;foo,1,2,3&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">ReaderBuilder</span>::<span class="ident">new</span>()
         .<span class="ident">has_headers</span>(<span class="bool-val">false</span>)
         .<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">deserialize</span>();

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
             <span class="ident">label</span>: <span class="string">&quot;foo&quot;</span>.<span class="ident">to_string</span>(),
             <span class="ident">values</span>: <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],
         });
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>

<p>In the above example, adding another field to the <code>Row</code> struct after
 the <code>values</code> field will result in a deserialization error. This is
 because the deserializer doesn&#39;t know when to stop reading fields
 into the <code>values</code> vector, so it will consume the rest of the fields in
 the record leaving none left over for the additional field.</p>

<p>Finally, simple enums in Rust can be deserialized as well. Namely,
 enums must either be variants with no arguments or variants with a
 single argument. Variants with no arguments are deserialized based on
 which variant name the field matches. Variants with a single argument
 are deserialized based on which variant can store the data. The latter
 is only supported when using &quot;untagged&quot; enum deserialization. The
 following example shows both forms in action:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;
 <span class="attribute">#[<span class="ident">macro_use</span>]</span>
 <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_derive</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">PartialEq</span>)]</span>
 <span class="kw">struct</span> <span class="ident">Row</span> {
     <span class="ident">label</span>: <span class="ident">Label</span>,
     <span class="ident">value</span>: <span class="ident">Number</span>,
 }

 <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">PartialEq</span>)]</span>
 <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename_all</span> <span class="op">=</span> <span class="string">&quot;lowercase&quot;</span>)]</span>
 <span class="kw">enum</span> <span class="ident">Label</span> {
     <span class="ident">Celsius</span>,
     <span class="ident">Fahrenheit</span>,
 }

 <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">PartialEq</span>)]</span>
 <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">untagged</span>)]</span>
 <span class="kw">enum</span> <span class="ident">Number</span> {
     <span class="ident">Integer</span>(<span class="ident">i64</span>),
     <span class="ident">Float</span>(<span class="ident">f64</span>),
 }

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
label,value
celsius,22.2222
fahrenheit,72
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">deserialize</span>();

     <span class="comment">// Read the first record.</span>
     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
             <span class="ident">label</span>: <span class="ident">Label</span>::<span class="ident">Celsius</span>,
             <span class="ident">value</span>: <span class="ident">Number</span>::<span class="ident">Float</span>(<span class="number">22.2222</span>),
         });
     } <span class="kw">else</span> {
         <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(
             <span class="string">&quot;expected at least two records but got none&quot;</span>));
     }

     <span class="comment">// Read the second record.</span>
     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
             <span class="ident">label</span>: <span class="ident">Label</span>::<span class="ident">Fahrenheit</span>,
             <span class="ident">value</span>: <span class="ident">Number</span>::<span class="ident">Integer</span>(<span class="number">72</span>),
         });
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(
             <span class="string">&quot;expected at least two records but got only one&quot;</span>))
     }
 }</pre>
</div><h4 id='method.into_deserialize' class="method"><span id='into_deserialize.v' class='invisible'><code>fn <a href='#method.into_deserialize' class='fnname'>into_deserialize</a>&lt;D&gt;(self) -&gt; <a class="struct" href="../csv/struct.DeserializeRecordsIntoIter.html" title="struct csv::DeserializeRecordsIntoIter">DeserializeRecordsIntoIter</a>&lt;R, D&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Returns an owned iterator over deserialized records.</p>

<p>Each item yielded by this iterator is a <code>Result&lt;D, Error&gt;</code>.
 Therefore, in order to access the record, callers must handle the
 possibility of error (typically with <code>try!</code> or <code>?</code>).</p>

<p>This is mostly useful when you want to return a CSV iterator or store
 it somewhere.</p>

<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
 default), then this does not include the first record. Additionally,
 if <code>has_headers</code> is enabled, then deserializing into a struct will
 automatically align the values in each row to the fields of a struct
 based on the header row.</p>

<p>For more detailed deserialization rules, see the documentation on the
 <code>deserialize</code> method.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;
 <span class="attribute">#[<span class="ident">macro_use</span>]</span>
 <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_derive</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
 <span class="kw">struct</span> <span class="ident">Row</span> {
     <span class="ident">city</span>: <span class="ident">String</span>,
     <span class="ident">country</span>: <span class="ident">String</span>,
     <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;popcount&quot;</span>)]</span>
     <span class="ident">population</span>: <span class="ident">u64</span>,
 }

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_deserialize</span>();

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
             <span class="ident">city</span>: <span class="string">&quot;Boston&quot;</span>.<span class="ident">to_string</span>(),
             <span class="ident">country</span>: <span class="string">&quot;United States&quot;</span>.<span class="ident">to_string</span>(),
             <span class="ident">population</span>: <span class="number">4628910</span>,
         });
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>
</div><h4 id='method.records' class="method"><span id='records.v' class='invisible'><code>fn <a href='#method.records' class='fnname'>records</a>(&amp;mut self) -&gt; <a class="struct" href="../csv/struct.StringRecordsIter.html" title="struct csv::StringRecordsIter">StringRecordsIter</a>&lt;R&gt;</code></span></h4>
<div class='docblock'><p>Returns a borrowed iterator over all records as strings.</p>

<p>Each item yielded by this iterator is a <code>Result&lt;StringRecord, Error&gt;</code>.
 Therefore, in order to access the record, callers must handle the
 possibility of error (typically with <code>try!</code> or <code>?</code>).</p>

<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
 default), then this does not include the first record.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">records</span>();

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>
</div><h4 id='method.into_records' class="method"><span id='into_records.v' class='invisible'><code>fn <a href='#method.into_records' class='fnname'>into_records</a>(self) -&gt; <a class="struct" href="../csv/struct.StringRecordsIntoIter.html" title="struct csv::StringRecordsIntoIter">StringRecordsIntoIter</a>&lt;R&gt;</code></span></h4>
<div class='docblock'><p>Returns an owned iterator over all records as strings.</p>

<p>Each item yielded by this iterator is a <code>Result&lt;StringRecord, Error&gt;</code>.
 Therefore, in order to access the record, callers must handle the
 possibility of error (typically with <code>try!</code> or <code>?</code>).</p>

<p>This is mostly useful when you want to return a CSV iterator or store
 it somewhere.</p>

<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
 default), then this does not include the first record.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_records</span>();

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>
</div><h4 id='method.byte_records' class="method"><span id='byte_records.v' class='invisible'><code>fn <a href='#method.byte_records' class='fnname'>byte_records</a>(&amp;mut self) -&gt; <a class="struct" href="../csv/struct.ByteRecordsIter.html" title="struct csv::ByteRecordsIter">ByteRecordsIter</a>&lt;R&gt;</code></span></h4>
<div class='docblock'><p>Returns a borrowed iterator over all records as raw bytes.</p>

<p>Each item yielded by this iterator is a <code>Result&lt;ByteRecord, Error&gt;</code>.
 Therefore, in order to access the record, callers must handle the
 possibility of error (typically with <code>try!</code> or <code>?</code>).</p>

<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
 default), then this does not include the first record.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">byte_records</span>();

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>
</div><h4 id='method.into_byte_records' class="method"><span id='into_byte_records.v' class='invisible'><code>fn <a href='#method.into_byte_records' class='fnname'>into_byte_records</a>(self) -&gt; <a class="struct" href="../csv/struct.ByteRecordsIntoIter.html" title="struct csv::ByteRecordsIntoIter">ByteRecordsIntoIter</a>&lt;R&gt;</code></span></h4>
<div class='docblock'><p>Returns an owned iterator over all records as raw bytes.</p>

<p>Each item yielded by this iterator is a <code>Result&lt;ByteRecord, Error&gt;</code>.
 Therefore, in order to access the record, callers must handle the
 possibility of error (typically with <code>try!</code> or <code>?</code>).</p>

<p>This is mostly useful when you want to return a CSV iterator or store
 it somewhere.</p>

<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
 default), then this does not include the first record.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_byte_records</span>();

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>
</div><h4 id='method.headers' class="method"><span id='headers.v' class='invisible'><code>fn <a href='#method.headers' class='fnname'>headers</a>(&amp;mut self) -&gt; <a class="type" href="../csv/type.Result.html" title="type csv::Result">Result</a>&lt;&amp;<a class="struct" href="../csv/struct.StringRecord.html" title="struct csv::StringRecord">StringRecord</a>&gt;</code></span></h4>
<div class='docblock'><p>Returns a reference to the first row read by this parser.</p>

<p>If no row has been read yet, then this will force parsing of the first
 row.</p>

<p>If there was a problem parsing the row or if it wasn&#39;t valid UTF-8,
 then this returns an error.</p>

<p>If the underlying reader emits EOF before any data, then this returns
 an empty record.</p>

<p>Note that this method may be used regardless of whether <code>has_headers</code>
 was enabled (but it is enabled by default).</p>

<p># Example</p>

<p>This example shows how to get the header row of CSV data. Notice that
 the header row does not appear as a record in the iterator!</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

     <span class="comment">// We can read the headers before iterating.</span>
     {
         <span class="comment">// `headers` borrows from the reader, so we put this in its</span>
         <span class="comment">// own scope. That way, the borrow ends before we try iterating</span>
         <span class="comment">// below. Alternatively, we could clone the headers.</span>
         <span class="kw">let</span> <span class="ident">headers</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">headers</span>()<span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">headers</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
     }

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">records</span>().<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
     } <span class="kw">else</span> {
         <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(
             <span class="string">&quot;expected at least one record but got none&quot;</span>))
     }

     <span class="comment">// We can also read the headers after iterating.</span>
     <span class="kw">let</span> <span class="ident">headers</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">headers</span>()<span class="question-mark">?</span>;
     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">headers</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
     <span class="prelude-val">Ok</span>(())
 }</pre>
</div><h4 id='method.byte_headers' class="method"><span id='byte_headers.v' class='invisible'><code>fn <a href='#method.byte_headers' class='fnname'>byte_headers</a>(&amp;mut self) -&gt; <a class="type" href="../csv/type.Result.html" title="type csv::Result">Result</a>&lt;&amp;<a class="struct" href="../csv/struct.ByteRecord.html" title="struct csv::ByteRecord">ByteRecord</a>&gt;</code></span></h4>
<div class='docblock'><p>Returns a reference to the first row read by this parser as raw bytes.</p>

<p>If no row has been read yet, then this will force parsing of the first
 row.</p>

<p>If there was a problem parsing the row then this returns an error.</p>

<p>If the underlying reader emits EOF before any data, then this returns
 an empty record.</p>

<p>Note that this method may be used regardless of whether <code>has_headers</code>
 was enabled (but it is enabled by default).</p>

<p># Example</p>

<p>This example shows how to get the header row of CSV data. Notice that
 the header row does not appear as a record in the iterator!</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::<span class="ident">Reader</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

     <span class="comment">// We can read the headers before iterating.</span>
     {
         <span class="comment">// `headers` borrows from the reader, so we put this in its</span>
         <span class="comment">// own scope. That way, the borrow ends before we try iterating</span>
         <span class="comment">// below. Alternatively, we could clone the headers.</span>
         <span class="kw">let</span> <span class="ident">headers</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">byte_headers</span>()<span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">headers</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
     }

     <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">byte_records</span>().<span class="ident">next</span>() {
         <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
     } <span class="kw">else</span> {
         <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(
             <span class="string">&quot;expected at least one record but got none&quot;</span>))
     }

     <span class="comment">// We can also read the headers after iterating.</span>
     <span class="kw">let</span> <span class="ident">headers</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">byte_headers</span>()<span class="question-mark">?</span>;
     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">headers</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
     <span class="prelude-val">Ok</span>(())
 }</pre>
</div><h4 id='method.set_headers' class="method"><span id='set_headers.v' class='invisible'><code>fn <a href='#method.set_headers' class='fnname'>set_headers</a>(&amp;mut self, headers: <a class="struct" href="../csv/struct.StringRecord.html" title="struct csv::StringRecord">StringRecord</a>)</code></span></h4>
<div class='docblock'><p>Set the headers of this CSV parser manually.</p>

<p>This overrides any other setting (including <code>set_byte_headers</code>). Any
 automatic detection of headers is disabled. This may be called at any
 time.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">StringRecord</span>};

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rdr</span>.<span class="ident">headers</span>()<span class="question-mark">?</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
     <span class="ident">rdr</span>.<span class="ident">set_headers</span>(<span class="ident">StringRecord</span>::<span class="ident">from</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));
     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rdr</span>.<span class="ident">headers</span>()<span class="question-mark">?</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);

     <span class="prelude-val">Ok</span>(())
 }</pre>
</div><h4 id='method.set_byte_headers' class="method"><span id='set_byte_headers.v' class='invisible'><code>fn <a href='#method.set_byte_headers' class='fnname'>set_byte_headers</a>(&amp;mut self, headers: <a class="struct" href="../csv/struct.ByteRecord.html" title="struct csv::ByteRecord">ByteRecord</a>)</code></span></h4>
<div class='docblock'><p>Set the headers of this CSV parser manually as raw bytes.</p>

<p>This overrides any other setting (including <code>set_headers</code>). Any
 automatic detection of headers is disabled. This may be called at any
 time.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">ByteRecord</span>};

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rdr</span>.<span class="ident">byte_headers</span>()<span class="question-mark">?</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
     <span class="ident">rdr</span>.<span class="ident">set_byte_headers</span>(<span class="ident">ByteRecord</span>::<span class="ident">from</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));
     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rdr</span>.<span class="ident">byte_headers</span>()<span class="question-mark">?</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);

     <span class="prelude-val">Ok</span>(())
 }</pre>
</div><h4 id='method.read_record' class="method"><span id='read_record.v' class='invisible'><code>fn <a href='#method.read_record' class='fnname'>read_record</a>(&amp;mut self, record: &amp;mut <a class="struct" href="../csv/struct.StringRecord.html" title="struct csv::StringRecord">StringRecord</a>) -&gt; <a class="type" href="../csv/type.Result.html" title="type csv::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code></span></h4>
<div class='docblock'><p>Read a single row into the given record. Returns false when no more
 records could be read.</p>

<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
 default), then this will never read the first record.</p>

<p>This method is useful when you want to read records as fast as
 as possible. It&#39;s less ergonomic than an iterator, but it permits the
 caller to reuse the <code>StringRecord</code> allocation, which usually results
 in higher throughput.</p>

<p>Records read via this method are guaranteed to have a position set
 on them, even if the reader is at EOF or if an error is returned.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">StringRecord</span>};

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">StringRecord</span>::<span class="ident">new</span>();

     <span class="kw">if</span> <span class="ident">rdr</span>.<span class="ident">read_record</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">record</span>)<span class="question-mark">?</span> {
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>
</div><h4 id='method.read_byte_record' class="method"><span id='read_byte_record.v' class='invisible'><code>fn <a href='#method.read_byte_record' class='fnname'>read_byte_record</a>(&amp;mut self, record: &amp;mut <a class="struct" href="../csv/struct.ByteRecord.html" title="struct csv::ByteRecord">ByteRecord</a>) -&gt; <a class="type" href="../csv/type.Result.html" title="type csv::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code></span></h4>
<div class='docblock'><p>Read a single row into the given byte record. Returns false when no
 more records could be read.</p>

<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
 default), then this will never read the first record.</p>

<p>This method is useful when you want to read records as fast as
 as possible. It&#39;s less ergonomic than an iterator, but it permits the
 caller to reuse the <code>ByteRecord</code> allocation, which usually results
 in higher throughput.</p>

<p>Records read via this method are guaranteed to have a position set
 on them, even if the reader is at EOF or if an error is returned.</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">ByteRecord</span>, <span class="ident">Reader</span>};

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">ByteRecord</span>::<span class="ident">new</span>();

     <span class="kw">if</span> <span class="ident">rdr</span>.<span class="ident">read_byte_record</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">record</span>)<span class="question-mark">?</span> {
         <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
         <span class="prelude-val">Ok</span>(())
     } <span class="kw">else</span> {
         <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
     }
 }</pre>
</div><h4 id='method.position' class="method"><span id='position.v' class='invisible'><code>fn <a href='#method.position' class='fnname'>position</a>(&amp;self) -&gt; &amp;<a class="struct" href="../csv/struct.Position.html" title="struct csv::Position">Position</a></code></span></h4>
<div class='docblock'><p>Return the current position of this CSV reader.</p>

<p>The byte offset in the position returned can be used to <code>seek</code> this
 reader. In particular, seeking to a position returned here on the same
 data will result in parsing the same subsequent record.</p>

<p># Example: reading the position</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">Position</span>};

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
     <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">io</span>::<span class="ident">Cursor</span>::<span class="ident">new</span>(<span class="ident">data</span>));
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_records</span>();
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">pos</span> <span class="op">=</span> <span class="ident">Position</span>::<span class="ident">new</span>();
     <span class="kw">loop</span> {
         <span class="comment">// Read the position immediately before each record.</span>
         <span class="kw">let</span> <span class="ident">next_pos</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">reader</span>().<span class="ident">position</span>().<span class="ident">clone</span>();
         <span class="kw">if</span> <span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>() {
             <span class="kw">break</span>;
         }
         <span class="ident">pos</span> <span class="op">=</span> <span class="ident">next_pos</span>;
     }

     <span class="comment">// `pos` should now be the position immediately before the last</span>
     <span class="comment">// record.</span>
     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">pos</span>.<span class="ident">byte</span>(), <span class="number">51</span>);
     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">pos</span>.<span class="ident">line</span>(), <span class="number">3</span>);
     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">pos</span>.<span class="ident">record</span>(), <span class="number">2</span>);
     <span class="prelude-val">Ok</span>(())
 }</pre>
</div><h4 id='method.is_done' class="method"><span id='is_done.v' class='invisible'><code>fn <a href='#method.is_done' class='fnname'>is_done</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>Returns true if and only if this reader has been exhausted.</p>

<p>When this returns true, no more records can be read from this reader
 (unless it has been seeked to another position).</p>

<p># Example</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
 <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;
 <span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">Position</span>};

 <span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
     <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
     <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">io</span>::<span class="ident">Cursor</span>::<span class="ident">new</span>(<span class="ident">data</span>));
     <span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">rdr</span>.<span class="ident">is_done</span>());
     <span class="kw">for</span> <span class="ident">result</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">records</span>() {
         <span class="kw">let</span> _ <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
     }
     <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rdr</span>.<span class="ident">is_done</span>());
     <span class="prelude-val">Ok</span>(())
 }</pre>
</div><h4 id='method.has_headers' class="method"><span id='has_headers.v' class='invisible'><code>fn <a href='#method.has_headers' class='fnname'>has_headers</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>Returns true if and only if this reader has been configured to
interpret the first record as a header record.</p>
</div><h4 id='method.get_ref' class="method"><span id='get_ref.v' class='invisible'><code>fn <a href='#method.get_ref' class='fnname'>get_ref</a>(&amp;self) -&gt; &amp;R</code></span></h4>
<div class='docblock'><p>Returns a reference to the underlying reader.</p>
</div><h4 id='method.get_mut' class="method"><span id='get_mut.v' class='invisible'><code>fn <a href='#method.get_mut' class='fnname'>get_mut</a>(&amp;mut self) -&gt; &amp;mut R</code></span></h4>
<div class='docblock'><p>Returns a mutable reference to the underlying reader.</p>
</div><h4 id='method.into_inner' class="method"><span id='into_inner.v' class='invisible'><code>fn <a href='#method.into_inner' class='fnname'>into_inner</a>(self) -&gt; R</code></span></h4>
<div class='docblock'><p>Unwraps this CSV reader, returning the underlying reader.</p>

<p>Note that any leftover data inside this reader&#39;s internal buffer is
lost.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Seek.html" title="trait std::io::Seek">Seek</a>&gt; <a class="struct" href="../csv/struct.Reader.html" title="struct csv::Reader">Reader</a>&lt;R&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/csv/reader.rs.html#1696-1802' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.seek' class="method"><span id='seek.v' class='invisible'><code>fn <a href='#method.seek' class='fnname'>seek</a>(&amp;mut self, pos: <a class="struct" href="../csv/struct.Position.html" title="struct csv::Position">Position</a>) -&gt; <a class="type" href="../csv/type.Result.html" title="type csv::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span></h4>
<div class='docblock'><p>Seeks the underlying reader to the position given.</p>

<p>This comes with a few caveats:</p>

<ul>
<li>Any internal buffer associated with this reader is cleared.</li>
<li>If the given position does not correspond to a position immediately
before the start of a record, then the behavior of this reader is
unspecified.</li>
<li><p>Any special logic that skips the first record in the CSV reader
when reading or iterating over records is disabled.</p>

<p>If the given position has a byte offset equivalent to the current
position, then no seeking is performed.</p>

<p>If the header row has not already been read, then this will attempt
to read the header row before seeking. Therefore, it is possible that
this returns an error associated with reading CSV data.</p>

<p>Note that seeking is performed based only on the byte offset in the
given position. Namely, the record or line numbers in the position may
be incorrect, but this will cause any future position generated by
this CSV reader to be similarly incorrect.</p>

<h1 id='example-seek-to-parse-a-record-twice' class='section-header'><a href='#example-seek-to-parse-a-record-twice'>Example: seek to parse a record twice</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">csv</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>;
<span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">Position</span>};

<span class="kw">fn</span> <span class="ident">example</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Error</span><span class="op">&gt;&gt;</span> {
 <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
 <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader</span>::<span class="ident">from_reader</span>(<span class="ident">io</span>::<span class="ident">Cursor</span>::<span class="ident">new</span>(<span class="ident">data</span>));
 <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_records</span>();
 <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">pos</span> <span class="op">=</span> <span class="ident">Position</span>::<span class="ident">new</span>();
 <span class="kw">loop</span> {
     <span class="comment">// Read the position immediately before each record.</span>
     <span class="kw">let</span> <span class="ident">next_pos</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">reader</span>().<span class="ident">position</span>().<span class="ident">clone</span>();
     <span class="kw">if</span> <span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>() {
         <span class="kw">break</span>;
     }
     <span class="ident">pos</span> <span class="op">=</span> <span class="ident">next_pos</span>;
 }

 <span class="comment">// Now seek the reader back to `pos`. This will let us read the</span>
 <span class="comment">// last record again.</span>
 <span class="ident">iter</span>.<span class="ident">reader_mut</span>().<span class="ident">seek</span>(<span class="ident">pos</span>)<span class="question-mark">?</span>;
 <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">into_reader</span>().<span class="ident">into_records</span>();
 <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
     <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
     <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">record</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;Concord&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;42695&quot;</span>]);
     <span class="prelude-val">Ok</span>(())
 } <span class="kw">else</span> {
     <span class="prelude-val">Err</span>(<span class="ident">From</span>::<span class="ident">from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
 }
}</pre></li>
</ul>
</div><h4 id='method.seek_raw' class="method"><span id='seek_raw.v' class='invisible'><code>fn <a href='#method.seek_raw' class='fnname'>seek_raw</a>(&amp;mut self, seek_from: <a class="enum" href="https://doc.rust-lang.org/nightly/std/io/enum.SeekFrom.html" title="enum std::io::SeekFrom">SeekFrom</a>, pos: <a class="struct" href="../csv/struct.Position.html" title="struct csv::Position">Position</a>) -&gt; <a class="type" href="../csv/type.Result.html" title="type csv::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span></h4>
<div class='docblock'><p>This is like <code>seek</code>, but provides direct control over how the seeking
operation is performed via <code>io::SeekFrom</code>.</p>

<p>The <code>pos</code> position given <em>should</em> correspond the position indicated
by <code>seek_from</code>, but there is no requirement. If the <code>pos</code> position
given is incorrect, then the position information returned by this
reader will be similarly incorrect.</p>

<p>If the header row has not already been read, then this will attempt
to read the header row before seeking. Therefore, it is possible that
this returns an error associated with reading CSV data.</p>

<p>Unlike <code>seek</code>, this will always cause an actual seek to be performed.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl&lt;R:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../csv/struct.Reader.html" title="struct csv::Reader">Reader</a>&lt;R&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/csv/reader.rs.html#645' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.fmt' class="method"><span id='fmt.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, __arg_0: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code></span></h4>
<div class='docblock'><p>Formats the value using the given formatter.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "csv";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>